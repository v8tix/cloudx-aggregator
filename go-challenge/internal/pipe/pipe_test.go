package pipe

import (
	"bytes"
	"github.com/cloudx-labs/challenge/internal/model/dto"
	"github.com/reactivex/rxgo/v2"
	"log/slog"
	"os"
	"testing"
)

var (
	associations = func() []uint8 {
		return []uint8{0x5b, 0x7b, 0x22, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x22, 0x3a, 0x22, 0x30, 0x34, 0x37, 0x33, 0x34, 0x30, 0x62, 0x33, 0x2d, 0x30, 0x36, 0x32, 0x36, 0x2d, 0x34, 0x38, 0x62, 0x64, 0x2d, 0x38, 0x36, 0x62, 0x36, 0x2d, 0x62, 0x61, 0x39, 0x31, 0x32, 0x61, 0x63, 0x64, 0x35, 0x64, 0x35, 0x38, 0x22, 0x2c, 0x22, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x22, 0x3a, 0x22, 0x30, 0x34, 0x65, 0x65, 0x31, 0x39, 0x38, 0x36, 0x2d, 0x36, 0x32, 0x64, 0x36, 0x2d, 0x34, 0x39, 0x31, 0x33, 0x2d, 0x62, 0x66, 0x36, 0x64, 0x2d, 0x37, 0x64, 0x39, 0x31, 0x61, 0x62, 0x31, 0x39, 0x30, 0x32, 0x64, 0x35, 0x22, 0x7d, 0x2c, 0x7b, 0x22, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x22, 0x3a, 0x22, 0x39, 0x63, 0x38, 0x34, 0x32, 0x65, 0x30, 0x31, 0x2d, 0x63, 0x39, 0x34, 0x37, 0x2d, 0x34, 0x31, 0x30, 0x65, 0x2d, 0x39, 0x37, 0x62, 0x61, 0x2d, 0x62, 0x32, 0x35, 0x33, 0x31, 0x62, 0x39, 0x62, 0x32, 0x62, 0x63, 0x38, 0x22, 0x2c, 0x22, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x22, 0x3a, 0x22, 0x36, 0x37, 0x61, 0x62, 0x35, 0x37, 0x30, 0x65, 0x2d, 0x63, 0x36, 0x31, 0x34, 0x2d, 0x34, 0x36, 0x35, 0x38, 0x2d, 0x61, 0x63, 0x32, 0x62, 0x2d, 0x32, 0x31, 0x34, 0x39, 0x33, 0x38, 0x61, 0x33, 0x32, 0x33, 0x64, 0x64, 0x22, 0x7d, 0x2c, 0x7b, 0x22, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x22, 0x3a, 0x22, 0x39, 0x38, 0x31, 0x31, 0x36, 0x38, 0x61, 0x37, 0x2d, 0x37, 0x36, 0x32, 0x32, 0x2d, 0x34, 0x31, 0x31, 0x61, 0x2d, 0x38, 0x62, 0x30, 0x33, 0x2d, 0x39, 0x65, 0x65, 0x65, 0x31, 0x32, 0x37, 0x63, 0x62, 0x38, 0x33, 0x64, 0x22, 0x2c, 0x22, 0x63, 0x68, 0x69, 0x6c, 0x64, 0x72, 0x65, 0x6e, 0x22, 0x3a, 0x22, 0x30, 0x65, 0x38, 0x34, 0x31, 0x31, 0x63, 0x31, 0x2d, 0x35, 0x32, 0x38, 0x38, 0x2d, 0x34, 0x38, 0x37, 0x61, 0x2d, 0x61, 0x37, 0x30, 0x66, 0x2d, 0x38, 0x61, 0x31, 0x34, 0x31, 0x31, 0x34, 0x65, 0x33, 0x39, 0x65, 0x66, 0x22, 0x7d, 0x5d}
	}()
	message = func() []uint8 {
		return []uint8{0x7b, 0x22, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0x3a, 0x22, 0x66, 0x63, 0x64, 0x35, 0x62, 0x66, 0x64, 0x63, 0x2d, 0x62, 0x65, 0x36, 0x31, 0x2d, 0x34, 0x35, 0x62, 0x35, 0x2d, 0x61, 0x38, 0x32, 0x37, 0x2d, 0x37, 0x65, 0x36, 0x36, 0x30, 0x34, 0x31, 0x30, 0x63, 0x37, 0x62, 0x61, 0x22, 0x2c, 0x22, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x3a, 0x22, 0x32, 0x30, 0x64, 0x36, 0x38, 0x35, 0x35, 0x37, 0x2d, 0x63, 0x66, 0x35, 0x38, 0x2d, 0x34, 0x65, 0x65, 0x34, 0x2d, 0x61, 0x63, 0x30, 0x61, 0x2d, 0x63, 0x63, 0x36, 0x36, 0x62, 0x31, 0x35, 0x65, 0x35, 0x31, 0x65, 0x66, 0x22, 0x2c, 0x22, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x22, 0x3a, 0x22, 0x50, 0x41, 0x54, 0x43, 0x48, 0x22, 0x2c, 0x22, 0x70, 0x61, 0x74, 0x68, 0x22, 0x3a, 0x22, 0x2f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x22, 0x2c, 0x22, 0x68, 0x74, 0x74, 0x70, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x22, 0x3a, 0x34, 0x30, 0x30, 0x7d}
	}()
	corruptedBytes = func() []uint8 {
		return []uint8{0x5b}
	}()
	logger = func() *slog.Logger {
		return slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: slog.LevelDebug}))
	}()
	associationsObs = func() AssociationsObservable {
		return NewAssociationsObservable(logger)
	}()
	messageObs = func() MessageObservable {
		return NewMessageObservable(logger)
	}()
	groupObs = func() GroupObservable {
		return NewGroupObservable(logger)
	}()
)

func TestObservableWithByteArrayProducerReturnsByteArray(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		input []uint8
		want  []uint8
	}{
		"with byte array": {
			input: associations,
			want:  associations,
		},
	}

	for description, tc := range cases {
		t.Run(description, func(t *testing.T) {
			ch := make(chan rxgo.Item)
			go func() {
				ch <- rxgo.Of(tc.input)
				close(ch)
			}()

			observable := rxgo.FromChannel(ch)
			for item := range observable.Observe() {
				got := item.V.([]uint8)
				if !bytes.Equal(got, tc.want) {
					t.Fatalf("Expected: %v, Got: %v", tc.want, got)
				}
			}
		})
	}
}

func TestAreAssociationsWithValidByteArrayReturnsAssociationsArray(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		input []uint8
		want  []uint8
	}{
		"with byte array": {
			input: associations,
			want:  associations,
		},
	}

	for description, tc := range cases {
		t.Run(description, func(t *testing.T) {
			ch := make(chan rxgo.Item)
			go func() {
				ch <- rxgo.Of(tc.input)
				close(ch)
			}()

			observable := rxgo.FromChannel(ch)
			for item := range observable.Observe() {
				got := item.V.([]uint8)
				if !bytes.Equal(got, tc.want) {
					t.Fatalf("Expected: %v, Got: %v", tc.want, got)
				}
			}
		})
	}
}

func TestAssociationsPipeWithValidAssociationsByteArrayReturnsAssociationsDTO(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		input []uint8
		want  bool
	}{
		"with byte array": {
			input: associations,
			want:  true,
		},
	}

	for description, tc := range cases {
		t.Run(description, func(t *testing.T) {
			ch := make(chan rxgo.Item)
			go func() {
				ch <- rxgo.Of(tc.input)
				close(ch)
			}()

			observable := rxgo.FromChannel(ch)
			associationsPipe := associationsObs.Pipe(observable)
			for item := range associationsPipe.Observe() {
				got := item.V.(*dto.AssociationsDTO)
				if len(*got.Associations) == 0 {
					t.Fatalf("Expected: %v, Got: %v", tc.want, got)
				}
			}
		})
	}
}

func TestMessagePipeWithValidMessageByteArrayReturnsMessageDTO(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		input []uint8
		want  bool
	}{
		"with byte array": {
			input: message,
			want:  true,
		},
	}

	for description, tc := range cases {
		t.Run(description, func(t *testing.T) {
			ch := make(chan rxgo.Item)
			go func() {
				ch <- rxgo.Of(tc.input)
				close(ch)
			}()

			observable := rxgo.FromChannel(ch)
			messagePipe := messageObs.Pipe(observable)
			for item := range messagePipe.Observe() {
				got := item.V.(*dto.MessageDTO)
				if got.Message == nil {
					t.Fatalf("Expected: %v, Got: %v", tc.want, got)
				}
			}
		})
	}
}

func TestGroupPipeWithValidMessageAndValidAssociationsByteArrayReturnsGroupDTO(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		message      []uint8
		associations []uint8
		want         bool
	}{
		"with byte arrays": {
			message:      message,
			associations: associations,
			want:         false,
		},
	}

	for description, tc := range cases {
		t.Run(description, func(t *testing.T) {
			messageCh := make(chan rxgo.Item)
			associationCh := make(chan rxgo.Item)

			go func() {
				messageCh <- rxgo.Of(tc.message)
				associationCh <- rxgo.Of(tc.associations)
				close(messageCh)
				close(associationCh)
			}()

			messageObservable := rxgo.FromChannel(messageCh)
			associationObservable := rxgo.FromChannel(associationCh)
			messagePipe := messageObs.Pipe(messageObservable)
			associationPipe := associationsObs.Pipe(associationObservable)
			groupPipe := groupObs.Pipe(messagePipe, associationPipe)
			for item := range groupPipe.Observe() {
				got := item.V.(*dto.GroupDTO)
				if (got.MessageDTO == nil && got.AssociationsDTO == nil) && tc.want {
					t.Fatalf("Expected: %v, Got: %v", tc.want, got)
				}
			}
		})
	}
}

func TestAssociationsPipeWithNoisyByteArrayReturnsZeroItems(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		input []uint8
		want  int
	}{
		"with noisy byte array": {
			input: corruptedBytes,
			want:  0,
		},
	}

	for description, tc := range cases {
		t.Run(description, func(t *testing.T) {
			ch := make(chan rxgo.Item)
			go func() {
				ch <- rxgo.Of(tc.input)
				close(ch)
			}()

			observable := rxgo.FromChannel(ch)
			associationsPipe := associationsObs.Pipe(observable)
			for range associationsPipe.Observe() {
				t.Fatalf("Expected: %v, Got: %v", tc.want, 1)
			}
		})
	}
}

func TestMessagePipeWithNoisyByteArrayReturnsZeroItems(t *testing.T) {
	t.Parallel()

	cases := map[string]struct {
		input []uint8
		want  int
	}{
		"with noisy byte array": {
			input: corruptedBytes,
			want:  0,
		},
	}

	for description, tc := range cases {
		t.Run(description, func(t *testing.T) {
			ch := make(chan rxgo.Item)
			go func() {
				ch <- rxgo.Of(tc.input)
				close(ch)
			}()

			observable := rxgo.FromChannel(ch)
			messagePipe := messageObs.Pipe(observable)
			for range messagePipe.Observe() {
				t.Fatalf("Expected: %v, Got: %v", tc.want, 1)
			}
		})
	}
}
